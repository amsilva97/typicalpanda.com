import { getLanguageDefinition } from './core';
import { SupportedLanguage } from './core';

/**
 * Represents a single step in a generation path
 */
export interface GenerationStep {
    pattern: string;
    position: number;
    addedText: string;
    remainingName: string;
}

/**
 * Represents a complete generation path for a name
 */
export interface GenerationPath {
    steps: GenerationStep[];
    isValid: boolean;
    completionRate: number; // Percentage of name covered by this path
}

/**
 * Result of analyzing a name
 */
export interface NameAnalysis {
    name: string;
    language: SupportedLanguage;
    possiblePaths: GenerationPath[];
    bestPath: GenerationPath | null;
    confidence: number; // 0-1 score of how likely this name was generated by this language
}

/**
 * Analyze a name against a specific language
 */
export function analyzeName(name: string, language: SupportedLanguage): string[][] {
    const patternDefinition = getLanguageDefinition(language);
    const patterns = patternDefinition.patterns;
    const validPaths: string[][] = [];
    const pathsToCheck: { segments: string[], remaining: string }[] = [{ segments: [], remaining: name.toLowerCase() }];

    while (pathsToCheck.length > 0) {
        const currentItem = pathsToCheck.pop();
        if (!currentItem) continue;

        const { segments, remaining } = currentItem;

        // If no remaining text, we found a complete path
        if (remaining === '') {
            validPaths.push([...segments]);
            continue;
        }

        // Try different segment lengths from the remaining text
        for (let i = 1; i <= remaining.length; i++) {
            const segment = remaining.slice(0, i);
            const newRemaining = remaining.slice(i);

            if (patterns[segment]) {
                // Create new path with this segment added
                const newSegments = [...segments, segment];
                pathsToCheck.push({ segments: newSegments, remaining: newRemaining });
            }
        }
    }

    // Sort paths by segment count (longer paths first)
    const sortedPaths = validPaths.sort((a, b) => a.length - b.length);
    console.log(sortedPaths);

    return sortedPaths;
}
