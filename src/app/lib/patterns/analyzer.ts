import { LanguageDefinition, SupportedLanguage, getLanguageDefinition } from './generations';

/**
 * Represents a single step in a generation path
 */
export interface GenerationStep {
  pattern: string;
  position: number;
  addedText: string;
  remainingName: string;
}

/**
 * Represents a complete generation path for a name
 */
export interface GenerationPath {
  steps: GenerationStep[];
  isValid: boolean;
  completionRate: number; // Percentage of name covered by this path
}

/**
 * Result of analyzing a name
 */
export interface NameAnalysis {
  name: string;
  language: SupportedLanguage;
  possiblePaths: GenerationPath[];
  bestPath: GenerationPath | null;
  confidence: number; // 0-1 score of how likely this name was generated by this language
}

/**
 * Find all possible generation paths that could have produced the given name
 * Only returns paths with 100% completion rate (complete matches)
 */
export function findAllGenerationPaths(name: string, language: LanguageDefinition): GenerationPath[] {
  const paths: GenerationPath[] = [];
  const normalizedName = name.toLowerCase().replace(/[^a-z]/g, ''); // Remove non-letters and lowercase
  
  if (normalizedName.length === 0) {
    return paths;
  }

  // Start recursive search from the start marker
  const startMarker = language.options.startMarker;
  findPathsRecursive(
    normalizedName,
    0, // Current position in the name
    startMarker, // Current pattern
    [], // Steps taken so far
    language,
    paths
  );

  // Filter to only return paths with 100% completion rate
  return paths.filter(path => path.completionRate === 1.0 && path.isValid);
}

/**
 * Recursive function to find generation paths
 */
function findPathsRecursive(
  targetName: string,
  currentPosition: number,
  currentPattern: string,
  steps: GenerationStep[],
  language: LanguageDefinition,
  foundPaths: GenerationPath[]
): void {
  // If we've consumed the entire name, this is a valid path
  if (currentPosition >= targetName.length) {
    const completionRate = currentPosition / targetName.length;
    foundPaths.push({
      steps: [...steps],
      isValid: true,
      completionRate: completionRate
    });
    return;
  }

  // Get possible continuations from current pattern
  const possibilities = language.patterns[currentPattern] || [];
  
  for (const nextPattern of possibilities) {
    // Skip end marker unless we're at the end
    if (nextPattern === language.options.endMarker) {
      if (currentPosition >= targetName.length) {
        const completionRate = currentPosition / targetName.length;
        foundPaths.push({
          steps: [...steps],
          isValid: true,
          completionRate: completionRate
        });
      }
      continue;
    }

    // Check if this pattern matches the remaining part of the name
    const remainingName = targetName.substring(currentPosition);
    
    if (remainingName.startsWith(nextPattern)) {
      // This pattern matches! Add it to the path and continue
      const newStep: GenerationStep = {
        pattern: nextPattern,
        position: currentPosition,
        addedText: nextPattern,
        remainingName: remainingName
      };

      const newSteps = [...steps, newStep];
      const newPosition = currentPosition + nextPattern.length;

      // Continue recursively
      findPathsRecursive(
        targetName,
        newPosition,
        nextPattern, // The pattern we just added becomes the new current pattern
        newSteps,
        language,
        foundPaths
      );
    }
  }

  // We only care about complete matches, so no need to track partial paths
}

/**
 * Analyze a name against a specific language to find how it could have been generated
 * Only returns complete matches (100% completion rate)
 */
export function analyzeNameForLanguage(name: string, language: SupportedLanguage): NameAnalysis {
  const languageDefinition = getLanguageDefinition(language);
  const possiblePaths = findAllGenerationPaths(name, languageDefinition);
  
  // Since we only get complete matches, all paths are valid with 100% completion
  let bestPath: GenerationPath | null = null;
  
  if (possiblePaths.length > 0) {
    // All paths are equally valid (100% completion), so just pick the first one
    bestPath = possiblePaths[0];
  }

  // Calculate confidence score - either 1.0 (complete match) or 0 (no match)
  let confidence = 0;
  if (possiblePaths.length > 0) {
    confidence = 1.0; // All matches are complete matches
    
    // Bonus for having multiple valid paths (indicates name fits pattern well)
    if (possiblePaths.length > 1) {
      confidence = Math.min(1.0, confidence + 0.05 * (possiblePaths.length - 1));
    }
  }

  return {
    name,
    language,
    possiblePaths,
    bestPath,
    confidence
  };
}

/**
 * Analyze a name against all supported languages to find the best match
 */
export function analyzeName(name: string): NameAnalysis[] {
  const analyses: NameAnalysis[] = [];
  
  // Analyze against each supported language
  for (const language of Object.values(SupportedLanguage)) {
    const analysis = analyzeNameForLanguage(name, language);
    analyses.push(analysis);
  }

  // Sort by confidence (highest first)
  return analyses.sort((a, b) => b.confidence - a.confidence);
}