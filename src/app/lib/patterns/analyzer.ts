import { LanguageDefinition, SupportedLanguage, getLanguageDefinition } from './generations';

/**
 * Represents a single step in a generation path
 */
export interface GenerationStep {
  pattern: string;
  position: number;
  addedText: string;
  remainingName: string;
}

/**
 * Represents a complete generation path for a name
 */
export interface GenerationPath {
  steps: GenerationStep[];
  isValid: boolean;
  completionRate: number; // Percentage of name covered by this path
}

/**
 * Result of analyzing a name
 */
export interface NameAnalysis {
  name: string;
  language: SupportedLanguage;
  possiblePaths: GenerationPath[];
  bestPath: GenerationPath | null;
  confidence: number; // 0-1 score of how likely this name was generated by this language
}

/**
 * Find all possible generation paths that could have produced the given name
 */
export function findAllGenerationPaths(name: string, language: LanguageDefinition): GenerationPath[] {
  const paths: GenerationPath[] = [];
  const normalizedName = name.toLowerCase().replace(/[^a-z]/g, ''); // Remove non-letters and lowercase
  
  if (normalizedName.length === 0) {
    return paths;
  }

  // Start recursive search from the start marker
  const startMarker = language.options.startMarker;
  findPathsRecursive(
    normalizedName,
    0, // Current position in the name
    startMarker, // Current pattern
    [], // Steps taken so far
    language,
    paths
  );

  return paths;
}

/**
 * Recursive function to find generation paths
 */
function findPathsRecursive(
  targetName: string,
  currentPosition: number,
  currentPattern: string,
  steps: GenerationStep[],
  language: LanguageDefinition,
  foundPaths: GenerationPath[]
): void {
  // If we've consumed the entire name, this is a valid path
  if (currentPosition >= targetName.length) {
    const completionRate = currentPosition / targetName.length;
    foundPaths.push({
      steps: [...steps],
      isValid: true,
      completionRate: completionRate
    });
    return;
  }

  // Get possible continuations from current pattern
  const possibilities = language.patterns[currentPattern] || [];
  
  for (const nextPattern of possibilities) {
    // Skip end marker unless we're at the end
    if (nextPattern === language.options.endMarker) {
      if (currentPosition >= targetName.length) {
        const completionRate = currentPosition / targetName.length;
        foundPaths.push({
          steps: [...steps],
          isValid: true,
          completionRate: completionRate
        });
      }
      continue;
    }

    // Check if this pattern matches the remaining part of the name
    const remainingName = targetName.substring(currentPosition);
    
    if (remainingName.startsWith(nextPattern)) {
      // This pattern matches! Add it to the path and continue
      const newStep: GenerationStep = {
        pattern: nextPattern,
        position: currentPosition,
        addedText: nextPattern,
        remainingName: remainingName
      };

      const newSteps = [...steps, newStep];
      const newPosition = currentPosition + nextPattern.length;

      // Continue recursively
      findPathsRecursive(
        targetName,
        newPosition,
        nextPattern, // The pattern we just added becomes the new current pattern
        newSteps,
        language,
        foundPaths
      );
    }
  }

  // If we didn't find any valid continuations and haven't reached the end,
  // this is a partial path
  if (currentPosition < targetName.length && currentPosition > 0) {
    const completionRate = currentPosition / targetName.length;
    if (completionRate > 0.3) { // Only include paths that cover at least 30% of the name
      foundPaths.push({
        steps: [...steps],
        isValid: false,
        completionRate: completionRate
      });
    }
  }
}

/**
 * Analyze a name against a specific language to find how it could have been generated
 */
export function analyzeNameForLanguage(name: string, language: SupportedLanguage): NameAnalysis {
  const languageDefinition = getLanguageDefinition(language);
  const possiblePaths = findAllGenerationPaths(name, languageDefinition);
  
  // Find the best path (highest completion rate among valid paths, or best partial path)
  let bestPath: GenerationPath | null = null;
  
  // First, look for complete valid paths
  const validPaths = possiblePaths.filter(p => p.isValid);
  if (validPaths.length > 0) {
    bestPath = validPaths.reduce((best, current) => 
      current.completionRate > best.completionRate ? current : best
    );
  } else {
    // If no valid paths, find the best partial path
    const partialPaths = possiblePaths.filter(p => !p.isValid);
    if (partialPaths.length > 0) {
      bestPath = partialPaths.reduce((best, current) => 
        current.completionRate > best.completionRate ? current : best
      );
    }
  }

  // Calculate confidence score
  let confidence = 0;
  if (bestPath) {
    confidence = bestPath.completionRate * (bestPath.isValid ? 1.0 : 0.7);
    
    // Bonus for having multiple valid paths (indicates name fits pattern well)
    if (validPaths.length > 1) {
      confidence = Math.min(1.0, confidence + 0.1);
    }
  }

  return {
    name,
    language,
    possiblePaths,
    bestPath,
    confidence
  };
}

/**
 * Analyze a name against all supported languages to find the best match
 */
export function analyzeName(name: string): NameAnalysis[] {
  const analyses: NameAnalysis[] = [];
  
  // Analyze against each supported language
  for (const language of Object.values(SupportedLanguage)) {
    const analysis = analyzeNameForLanguage(name, language);
    analyses.push(analysis);
  }

  // Sort by confidence (highest first)
  return analyses.sort((a, b) => b.confidence - a.confidence);
}