import { oldEnglish } from './oldEnglish';
import { LanguageDefinition } from './LanguageDefinition';
import { PatternNotFoundError, NoValidContinuationsError, MaxLoopsExceededError } from '../exceptions/PatternGenerationError';

export interface NameSegmentation {
  segments: string[];
  meanings: string[];
  isValid: boolean;
  patternPath?: string; // Shows the actual pattern progression like "^ → ael → ric → $"
}

export interface NameSuggestion {
  name: string;
  segments: string[];
  meanings: string[];
  similarity: number;
  reason: string;
}

export interface AnalysisResult {
  originalName: string;
  isGeneratable: boolean;
  segmentations: NameSegmentation[];
  suggestions: NameSuggestion[];
  totalCombinations: number;
}

/**
 * Analyzes a name and suggests better alternatives that are generatable
 */
export function analyzeName(inputName: string, language: LanguageDefinition): AnalysisResult {
  const name = inputName.toLowerCase().trim();
  if (!name) {
    return {
      originalName: inputName,
      isGeneratable: false,
      segmentations: [],
      suggestions: [],
      totalCombinations: 0
    };
  }

  const validSegmentations: NameSegmentation[] = [];

  // Find all possible ways to segment the name
  function findSegmentations(remainingName: string, currentSegments: string[], startIndex: number): void {
    // If we've consumed the entire name, this is a valid segmentation
    if (remainingName.length === 0) {
      // Verify this segmentation could be generated by checking pattern connections
      const validationResult = isValidGenerationWithPath(currentSegments, language);
      if (validationResult.isValid) {
        const meanings = currentSegments.map(segment => 
          language.meanings[segment] || 'unknown element'
        );
        
        validSegmentations.push({
          segments: [...currentSegments],
          meanings: meanings,
          isValid: true,
          patternPath: validationResult.patternPath
        });
      }
      return;
    }

    // Try all possible segments starting from current position
    // PRIORITIZE LONGER SEGMENTS FIRST - check from longest to shortest
    for (let i = remainingName.length; i >= 1; i--) {
      const segment = remainingName.substring(0, i);
      
      // Check if this segment exists in our patterns or meanings dictionary
      if (language.patterns.hasOwnProperty(segment) || language.meanings.hasOwnProperty(segment)) {
        // Recursively try to segment the rest
        findSegmentations(
          remainingName.substring(i),
          [...currentSegments, segment],
          startIndex + i
        );
      }
    }
  }

  // Start the segmentation process
  findSegmentations(name, [], 0);

  // Keep all valid segmentations (including different ways to reach the same segments)
  // Sort by pattern complexity (longer segments first, then by pattern path)
  const sortedSegmentations = validSegmentations.sort((a, b) => {
    // First, prefer segmentations with longer segments (fewer total segments)
    if (a.segments.length !== b.segments.length) {
      return a.segments.length - b.segments.length;
    }
    // Then sort by pattern path for consistency
    return (a.patternPath || "").localeCompare(b.patternPath || "");
  });

  // Generate suggestions for improvement
  const suggestions = generateNameSuggestions(inputName, sortedSegmentations.length > 0, language);

  return {
    originalName: inputName,
    isGeneratable: sortedSegmentations.length > 0,
    segmentations: sortedSegmentations,
    suggestions: suggestions,
    totalCombinations: sortedSegmentations.length
  };
}

/**
 * Checks if a sequence of segments could be validly generated by our pattern system
 * Returns both validation result and the pattern path
 */
function isValidGenerationWithPath(segments: string[], language: LanguageDefinition): { isValid: boolean; patternPath: string } {
  if (segments.length === 0) {
    return { isValid: false, patternPath: "" };
  }

  const pathElements: string[] = [language.options.startMarker];

  // Check if the first segment can start a name (appears in start marker pattern)
  const startingPatterns = language.patterns[language.options.startMarker] || [];
  if (!startingPatterns.includes(segments[0])) {
    return { isValid: false, patternPath: "" };
  }
  
  pathElements.push(segments[0]);

  // Check if each segment can lead to the next
  for (let i = 0; i < segments.length - 1; i++) {
    const currentSegment = segments[i];
    const nextSegment = segments[i + 1];
    
    const possibleContinuations = language.patterns[currentSegment] || [];
    if (!possibleContinuations.includes(nextSegment)) {
      return { isValid: false, patternPath: "" };
    }
    
    pathElements.push(nextSegment);
  }

  // Check if the last segment can end (has end marker in its possibilities)
  const lastSegment = segments[segments.length - 1];
  const lastPossibilities = language.patterns[lastSegment] || [];
  if (!lastPossibilities.includes(language.options.endMarker)) {
    return { isValid: false, patternPath: "" };
  }
  
  pathElements.push(language.options.endMarker);

  return { 
    isValid: true, 
    patternPath: pathElements.join(" → ") 
  };
}

/**
 * Checks if a sequence of segments could be validly generated by our pattern system (legacy)
 */
function isValidGeneration(segments: string[], language: LanguageDefinition): boolean {
  return isValidGenerationWithPath(segments, language).isValid;
}

/**
 * Removes duplicate segmentations based on segment arrays
 */
function removeDuplicateSegmentations(segmentations: NameSegmentation[]): NameSegmentation[] {
  const seen = new Set<string>();
  return segmentations.filter(seg => {
    const key = seg.segments.join('|');
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}

/**
 * Formats a segmentation for display
 */
export function formatSegmentation(segmentation: NameSegmentation): string {
  const segmentLines = segmentation.segments.map((segment, index) => {
    const meaning = segmentation.meanings[index];
    if (segmentation.segments.length === 1) {
      return `${segment}: ${meaning}`;
    } else if (index === 0) {
      return `${segment}-: ${meaning}`;
    } else if (index === segmentation.segments.length - 1) {
      return `-${segment}: ${meaning}`;
    } else {
      return `-${segment}-: ${meaning}`;
    }
  }).join('\n');

  // Add pattern path if available
  if (segmentation.patternPath) {
    return segmentLines + '\n\nPattern path: ' + segmentation.patternPath;
  }
  
  return segmentLines;
}

/**
 * Generates name suggestions based on the input name
 */
function generateNameSuggestions(inputName: string, isAlreadyGeneratable: boolean, language: LanguageDefinition): NameSuggestion[] {
  const suggestions: NameSuggestion[] = [];
  const name = inputName.toLowerCase();
  
  // Get all available starting elements
  const startingElements = language.patterns[language.options.startMarker] || [];
  
  // Strategy 1: Find similar sounding starting elements
  const similarStarts = startingElements.filter(start => {
    if (name.startsWith(start)) return false; // Don't suggest exact matches
    return hasSimilarSound(name.substring(0, Math.min(4, name.length)), start);
  });

  // Strategy 2: Extract recognizable parts and build around them
  const recognizedParts = findRecognizedParts(name, language);
  
  // Strategy 3: Sound-alike replacements
  const soundAlikes = generateSoundAlikeSuggestions(name, language);
  
  // Generate suggestions from similar starts
  for (const start of similarStarts.slice(0, 3)) {
    const compatibleEndings = getCompatibleEndings(start, language);
    for (const ending of compatibleEndings.slice(0, 2)) {
      const suggestedName = capitalizeFirst(start + ending);
      const segments = [start, ending];
      const meanings = segments.map(seg => language.meanings[seg] || 'unknown');
      const similarity = calculateSimilarity(name, start + ending);
      
      suggestions.push({
        name: suggestedName,
        segments: segments,
        meanings: meanings,
        similarity: similarity,
        reason: `Similar sound to "${inputName}" with authentic structure`
      });
    }
  }

  // Generate suggestions from recognized parts
  for (const part of recognizedParts.slice(0, 2)) {
    const alternatives = generateAlternativesWithPart(part, name, language);
    suggestions.push(...alternatives);
  }

  // Add sound-alike suggestions
  suggestions.push(...soundAlikes.slice(0, 3));

  // If the name is already generatable, suggest variations
  if (isAlreadyGeneratable) {
    const variations = generateVariations(name, language);
    suggestions.push(...variations.slice(0, 2));
  }

  // Remove duplicates and sort by similarity
  const uniqueSuggestions = removeDuplicateSuggestions(suggestions);
  return uniqueSuggestions
    .sort((a, b) => b.similarity - a.similarity)
    .slice(0, 6); // Return top 6 suggestions
}

/**
 * Checks if two strings have similar sounds
 */
function hasSimilarSound(str1: string, str2: string): boolean {
  if (str1.length === 0 || str2.length === 0) return false;
  
  // Check for similar starting sounds
  const firstChar1 = str1[0];
  const firstChar2 = str2[0];
  
  // Similar consonant groups
  const similarConsonants = [
    ['b', 'p'], ['d', 't'], ['g', 'k'], ['f', 'v'], 
    ['s', 'th'], ['l', 'r'], ['m', 'n']
  ];
  
  // Check if first characters are in the same similar group
  for (const group of similarConsonants) {
    if (group.includes(firstChar1) && group.includes(firstChar2)) {
      return true;
    }
  }
  
  // Check if they start with the same character
  return firstChar1 === firstChar2;
}

/**
 * Find parts of the name that are recognized elements from the language
 */
function findRecognizedParts(name: string, language: LanguageDefinition): string[] {
  const parts: string[] = [];
  const allElements = Object.keys(language.meanings);
  
  for (const element of allElements) {
    if (name.includes(element) && element.length >= 2) {
      parts.push(element);
    }
  }
  
  return parts.sort((a, b) => b.length - a.length); // Longer parts first
}

/**
 * Get endings that are compatible with a given starting element
 */
function getCompatibleEndings(start: string, language: LanguageDefinition): string[] {
  const possibleContinuations = language.patterns[start] || [];
  const endings: string[] = [];
  
  for (const continuation of possibleContinuations) {
    if (continuation === language.options.endMarker) continue; // Skip direct endings
    
    const continuationPossibilities = language.patterns[continuation] || [];
    if (continuationPossibilities.includes(language.options.endMarker)) {
      endings.push(continuation);
    }
  }
  
  return endings;
}

/**
 * Generate alternatives that include a specific recognized part
 */
function generateAlternativesWithPart(part: string, originalName: string, language: LanguageDefinition): NameSuggestion[] {
  const alternatives: NameSuggestion[] = [];
  const startingElements = language.patterns[language.options.startMarker] || [];
  
  // Try the part as an ending
  for (const start of startingElements.slice(0, 3)) {
    if (start === part) continue;
    
    const startPossibilities = language.patterns[start] || [];
    if (startPossibilities.includes(part)) {
      const suggestedName = capitalizeFirst(start + part);
      const similarity = calculateSimilarity(originalName, start + part);
      
      alternatives.push({
        name: suggestedName,
        segments: [start, part],
        meanings: [language.meanings[start] || 'unknown', language.meanings[part] || 'unknown'],
        similarity: similarity,
        reason: `Incorporates "${part}" from your original name with better structure`
      });
    }
  }
  
  return alternatives;
}

/**
 * Generate sound-alike suggestions
 */
function generateSoundAlikeSuggestions(name: string, language: LanguageDefinition): NameSuggestion[] {
  const suggestions: NameSuggestion[] = [];
  const startingElements = language.patterns[language.options.startMarker] || [];
  
  // Find starts that sound similar to the beginning of the name
  for (const start of startingElements) {
    if (hasSimilarSound(name.substring(0, 3), start)) {
      const compatibleEndings = getCompatibleEndings(start, language);
      for (const ending of compatibleEndings.slice(0, 1)) {
        const suggestedName = capitalizeFirst(start + ending);
        const similarity = calculateSimilarity(name, start + ending);
        
        suggestions.push({
          name: suggestedName,
          segments: [start, ending],
          meanings: [language.meanings[start] || 'unknown', language.meanings[ending] || 'unknown'],
          similarity: similarity,
          reason: `Sound-alike alternative with clearer meaning`
        });
      }
    }
  }
  
  return suggestions;
}

/**
 * Generate variations of an already valid name
 */
function generateVariations(name: string, language: LanguageDefinition): NameSuggestion[] {
  const variations: NameSuggestion[] = [];
  
  // This would implement variations like changing endings or prefixes
  // For now, return empty array
  
  return variations;
}

/**
 * Calculate similarity between two names (0-100)
 */
function calculateSimilarity(name1: string, name2: string): number {
  const len1 = name1.length;
  const len2 = name2.length;
  const maxLen = Math.max(len1, len2);
  
  if (maxLen === 0) return 100;
  
  // Simple similarity based on common characters and length
  let commonChars = 0;
  const minLen = Math.min(len1, len2);
  
  for (let i = 0; i < minLen; i++) {
    if (name1[i] === name2[i]) {
      commonChars++;
    }
  }
  
  // Bonus for similar length
  const lengthSimilarity = 1 - Math.abs(len1 - len2) / maxLen;
  const charSimilarity = commonChars / maxLen;
  
  return Math.round((lengthSimilarity * 0.3 + charSimilarity * 0.7) * 100);
}

/**
 * Remove duplicate suggestions
 */
function removeDuplicateSuggestions(suggestions: NameSuggestion[]): NameSuggestion[] {
  const seen = new Set<string>();
  return suggestions.filter(suggestion => {
    if (seen.has(suggestion.name.toLowerCase())) {
      return false;
    }
    seen.add(suggestion.name.toLowerCase());
    return true;
  });
}

/**
 * Capitalize first letter
 */
function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Quick check if a name is potentially analyzable (contains known elements)
 */
export function isNameAnalyzable(name: string, language: LanguageDefinition): boolean {
  const lowercaseName = name.toLowerCase();
  const allElements = [...Object.keys(language.patterns), ...Object.keys(language.meanings)];
  
  return allElements.some(element => lowercaseName.includes(element));
}

/**
 * Generic name analyzer that automatically selects the appropriate language
 * Currently defaults to Old English, but can be extended to detect language or use preferences
 */
export function analyzeNameGeneric(inputName: string): AnalysisResult {
  // For now, default to Old English
  // In the future, this could:
  // - Auto-detect the language based on patterns
  // - Use user preferences
  // - Accept a language parameter from URL/settings
  return analyzeName(inputName, oldEnglish);
}
// Helper function to deep copy the patterns object to avoid modifying the original
export function deepCopyPatterns(patterns: { [key: string]: string[]; }): { [key: string]: string[]; } {
  const copy: { [key: string]: string[]; } = {};
  for (const key in patterns) {
    copy[key] = [...patterns[key]];
  }
  return copy;
}/**
 * Attempts to break down a generated name into meaningful components
 * and construct a semantic meaning with visible word parts
 */
export function getNameMeaning(name: string, language: LanguageDefinition): string {
  const lowercaseName = name.toLowerCase();
  const meanings: string[] = [];
  const parts: string[] = [];
  let remainingName = lowercaseName;

  // Try to find the longest matching elements first
  const sortedElements = Object.keys(language.meanings).sort((a, b) => b.length - a.length);

  while (remainingName.length > 0) {
    let foundMatch = false;

    // Look for matching elements starting from the beginning of remaining name
    for (const element of sortedElements) {
      if (remainingName.startsWith(element)) {
        parts.push(element);
        meanings.push(language.meanings[element]);
        remainingName = remainingName.slice(element.length);
        foundMatch = true;
        break;
      }
    }

    // If no match found, skip one character and continue
    if (!foundMatch) {
      remainingName = remainingName.slice(1);
    }
  }

  // Construct meaning with parts on separate lines
  if (parts.length === 0) {
    return "";
  } else if (parts.length === 1) {
    return `${parts[0]}: ${meanings[0]}`;
  } else {
    // Format each part with prefix/suffix notation
    const formattedParts = parts.map((part, index) => {
      if (index === 0) {
        return `${part}-: ${meanings[index]}`;
      } else if (index === parts.length - 1) {
        return `-${part}: ${meanings[index]}`;
      } else {
        return `-${part}-: ${meanings[index]}`;
      }
    });

    return formattedParts.join('\n');
  }
}
/**
 * Extended function that returns both name and meaning
 */
export function generateNameWithMeaning(name: string, language: LanguageDefinition): { name: string; meaning: string; } {
  return {
    name: name,
    meaning: getNameMeaning(name, language)
  };
}
// Helper function to generate a single name using the pattern with length control and backtracking

export function generateName(language: LanguageDefinition, minLength?: number, maxLength?: number): string {
  const actualMinLength = minLength ?? language.options.minLength;
  const actualMaxLength = maxLength ?? language.options.maxLength;
  // Choose target length between min and max
  const targetLength = Math.floor(Math.random() * (actualMaxLength - actualMinLength + 1)) + actualMinLength;

  // Create a deep copy of patterns to track failed paths
  const workingPatterns = deepCopyPatterns(language.patterns);

  // Track generation state for backtracking
  interface GenerationState {
    currentPattern: string;
    generatedName: string;
    usedPath: string[];
  }

  const history: GenerationState[] = [];
  let currentPattern = language.options.startMarker;
  let generatedName = "";
  let loops = 0;
  const maxLoops = language.options.maxLoops;

  while (loops < maxLoops) {
    loops++;

    // Save current state to history for potential backtracking
    history.push({
      currentPattern,
      generatedName,
      usedPath: [currentPattern]
    });

    // Check if pattern exists in working patterns
    if (!workingPatterns.hasOwnProperty(currentPattern)) {
      // Pattern not found - backtrack
      if (history.length <= 1) {
        // Can't backtrack further, this is a fundamental pattern issue
        throw new PatternNotFoundError(currentPattern, generatedName, loops);
      }

      // Remove the failed choice from the previous state
      const currentState = history.pop()!; // Remove current state
      const previousState = history[history.length - 1]; // Get previous state


      // Remove the failed pattern from previous state's possibilities
      if (workingPatterns[previousState.currentPattern]) {
        workingPatterns[previousState.currentPattern] = workingPatterns[previousState.currentPattern].filter(
          p => p !== currentPattern
        );
      }

      // Restore to previous state
      currentPattern = previousState.currentPattern;
      generatedName = previousState.generatedName;

      continue; // Try again from previous state
    }

    // Get possible continuations for current pattern
    const possibilities = workingPatterns[currentPattern];

    if (!possibilities || possibilities.length === 0) {
      // No valid continuations - backtrack
      if (history.length <= 1) {
        throw new NoValidContinuationsError(currentPattern, generatedName, loops);
      }

      // Remove current state and go back
      const currentState = history.pop()!;
      const previousState = history[history.length - 1];

      // Mark this pattern as exhausted in the previous state
      if (workingPatterns[previousState.currentPattern]) {
        workingPatterns[previousState.currentPattern] = workingPatterns[previousState.currentPattern].filter(
          p => p !== currentPattern
        );
      }

      // Restore to previous state
      currentPattern = previousState.currentPattern;
      generatedName = previousState.generatedName;

      continue;
    }

    // Filter possibilities based on current length vs target
    const currentLength = generatedName.length;
    let filteredPossibilities: string[] = [];

    if (currentLength < targetLength) {
      // We haven't reached target length yet - skip endings
      filteredPossibilities = possibilities.filter(p => p !== language.options.endMarker);

      // If no non-ending possibilities, we must use what we have
      if (filteredPossibilities.length === 0) {
        filteredPossibilities = possibilities;
      }
    } else {
      // We've reached or exceeded target length - automatically take next end marker if available
      const hasEndOption = possibilities.includes(language.options.endMarker);
      if (hasEndOption) {
        // Immediately exit with end marker
        break;
      } else {
        // No ending available, continue with any option
        filteredPossibilities = possibilities;
      }
    }

    // If no valid filtered possibilities, backtrack
    if (filteredPossibilities.length === 0) {
      if (history.length <= 1) {
        throw new NoValidContinuationsError(currentPattern, generatedName, loops);
      }

      const currentState = history.pop()!;
      const previousState = history[history.length - 1];

      // Mark this path as failed
      if (workingPatterns[previousState.currentPattern]) {
        workingPatterns[previousState.currentPattern] = workingPatterns[previousState.currentPattern].filter(
          p => p !== currentPattern
        );
      }

      currentPattern = previousState.currentPattern;
      generatedName = previousState.generatedName;

      continue;
    }

    // Pick a random continuation from filtered array
    const nextPattern = filteredPossibilities[Math.floor(Math.random() * filteredPossibilities.length)];

    // If we hit the end marker, we're done
    if (nextPattern === language.options.endMarker) {
      break;
    }

    // Add the pattern to our name and continue
    generatedName += nextPattern;
    currentPattern = nextPattern;
  }

  // If we hit the loop limit, throw error
  if (loops >= maxLoops) {
    throw new MaxLoopsExceededError(maxLoops, generatedName, currentPattern);
  }

  // Capitalize first letter
  return generatedName.charAt(0).toUpperCase() + generatedName.slice(1);
}
// Generate multiple names with a language definition

export function generateNames(language: LanguageDefinition, count: number = 10, minLength?: number, maxLength?: number): string[] {
  const names: string[] = [];
  for (let i = 0; i < count; i++) {
    try {
      names.push(generateName(language, minLength, maxLength));
    } catch (error) {
      if (error instanceof MaxLoopsExceededError) {
        console.error('Pattern generation error - Max loops exceeded:', {
          errorCode: error.errorCode,
          context: error.context,
          message: error.message
        });
        names.push(error.context.generatedName + "~");
      } else if (error instanceof NoValidContinuationsError) {
        console.error('Pattern generation error - No valid continuations:', {
          errorCode: error.errorCode,
          context: error.context,
          message: error.message
        });
        names.push(error.context.generatedName + "~");
      } else if (error instanceof PatternNotFoundError) {
        console.error('Pattern generation error - Pattern not found:', {
          errorCode: error.errorCode,
          context: error.context,
          message: error.message
        });
        names.push(error.context.generatedName + "~");
      } else {
        // Unknown error, re-throw it
        console.error('Unknown pattern generation error:', error);
        throw error;
      }
    }
  }
  return names;
}
// Generate names with meanings using a language definition

export function generateNamesWithMeanings(language: LanguageDefinition, count: number = 10, minLength?: number, maxLength?: number): Array<{ name: string; meaning: string; }> {
  const namesWithMeanings: Array<{ name: string; meaning: string; }> = [];

  for (let i = 0; i < count; i++) {
    try {
      const name = generateName(language, minLength, maxLength);
      namesWithMeanings.push(generateNameWithMeaning(name, language));
    } catch (error) {
      if (error instanceof MaxLoopsExceededError) {
        console.error('Pattern generation error - Max loops exceeded:', {
          errorCode: error.errorCode,
          context: error.context,
          message: error.message
        });
        namesWithMeanings.push({
          name: error.context.generatedName + "~",
          meaning: "generation incomplete"
        });
      } else if (error instanceof NoValidContinuationsError) {
        console.error('Pattern generation error - No valid continuations:', {
          errorCode: error.errorCode,
          context: error.context,
          message: error.message
        });
        namesWithMeanings.push({
          name: error.context.generatedName + "~",
          meaning: "generation incomplete"
        });
      } else if (error instanceof PatternNotFoundError) {
        console.error('Pattern generation error - Pattern not found:', {
          errorCode: error.errorCode,
          context: error.context,
          message: error.message
        });
        namesWithMeanings.push({
          name: error.context.generatedName + "~",
          meaning: "generation incomplete"
        });
      } else {
        // Unknown error, re-throw it
        console.error('Unknown pattern generation error:', error);
        throw error;
      }
    }
  }

  return namesWithMeanings;
}

