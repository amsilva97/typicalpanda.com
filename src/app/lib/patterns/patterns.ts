import { LanguageDefinition, oldEnglish } from './oldEnglish';

export interface NameSegmentation {
  segments: string[];
  meanings: string[];
  isValid: boolean;
  patternPath?: string; // Shows the actual pattern progression like "^ → ael → ric → $"
}

export interface NameSuggestion {
  name: string;
  segments: string[];
  meanings: string[];
  similarity: number;
  reason: string;
}

export interface AnalysisResult {
  originalName: string;
  isGeneratable: boolean;
  segmentations: NameSegmentation[];
  suggestions: NameSuggestion[];
  totalCombinations: number;
}

/**
 * Analyzes a name and suggests better alternatives that are generatable
 */
export function analyzeName(inputName: string, language: LanguageDefinition): AnalysisResult {
  const name = inputName.toLowerCase().trim();
  if (!name) {
    return {
      originalName: inputName,
      isGeneratable: false,
      segmentations: [],
      suggestions: [],
      totalCombinations: 0
    };
  }

  const validSegmentations: NameSegmentation[] = [];

  // Find all possible ways to segment the name
  function findSegmentations(remainingName: string, currentSegments: string[], startIndex: number): void {
    // If we've consumed the entire name, this is a valid segmentation
    if (remainingName.length === 0) {
      // Verify this segmentation could be generated by checking pattern connections
      const validationResult = isValidGenerationWithPath(currentSegments, language);
      if (validationResult.isValid) {
        const meanings = currentSegments.map(segment => 
          language.meanings[segment] || 'unknown element'
        );
        
        validSegmentations.push({
          segments: [...currentSegments],
          meanings: meanings,
          isValid: true,
          patternPath: validationResult.patternPath
        });
      }
      return;
    }

    // Try all possible segments starting from current position
    // PRIORITIZE LONGER SEGMENTS FIRST - check from longest to shortest
    for (let i = remainingName.length; i >= 1; i--) {
      const segment = remainingName.substring(0, i);
      
      // Check if this segment exists in our patterns or meanings dictionary
      if (language.patterns.hasOwnProperty(segment) || language.meanings.hasOwnProperty(segment)) {
        // Recursively try to segment the rest
        findSegmentations(
          remainingName.substring(i),
          [...currentSegments, segment],
          startIndex + i
        );
      }
    }
  }

  // Start the segmentation process
  findSegmentations(name, [], 0);

  // Keep all valid segmentations (including different ways to reach the same segments)
  // Sort by pattern complexity (longer segments first, then by pattern path)
  const sortedSegmentations = validSegmentations.sort((a, b) => {
    // First, prefer segmentations with longer segments (fewer total segments)
    if (a.segments.length !== b.segments.length) {
      return a.segments.length - b.segments.length;
    }
    // Then sort by pattern path for consistency
    return (a.patternPath || "").localeCompare(b.patternPath || "");
  });

  // Generate suggestions for improvement
  const suggestions = generateNameSuggestions(inputName, sortedSegmentations.length > 0, language);

  return {
    originalName: inputName,
    isGeneratable: sortedSegmentations.length > 0,
    segmentations: sortedSegmentations,
    suggestions: suggestions,
    totalCombinations: sortedSegmentations.length
  };
}

/**
 * Checks if a sequence of segments could be validly generated by our pattern system
 * Returns both validation result and the pattern path
 */
function isValidGenerationWithPath(segments: string[], language: LanguageDefinition): { isValid: boolean; patternPath: string } {
  if (segments.length === 0) {
    return { isValid: false, patternPath: "" };
  }

  const pathElements: string[] = [language.options.startMarker];

  // Check if the first segment can start a name (appears in start marker pattern)
  const startingPatterns = language.patterns[language.options.startMarker] || [];
  if (!startingPatterns.includes(segments[0])) {
    return { isValid: false, patternPath: "" };
  }
  
  pathElements.push(segments[0]);

  // Check if each segment can lead to the next
  for (let i = 0; i < segments.length - 1; i++) {
    const currentSegment = segments[i];
    const nextSegment = segments[i + 1];
    
    const possibleContinuations = language.patterns[currentSegment] || [];
    if (!possibleContinuations.includes(nextSegment)) {
      return { isValid: false, patternPath: "" };
    }
    
    pathElements.push(nextSegment);
  }

  // Check if the last segment can end (has end marker in its possibilities)
  const lastSegment = segments[segments.length - 1];
  const lastPossibilities = language.patterns[lastSegment] || [];
  if (!lastPossibilities.includes(language.options.endMarker)) {
    return { isValid: false, patternPath: "" };
  }
  
  pathElements.push(language.options.endMarker);

  return { 
    isValid: true, 
    patternPath: pathElements.join(" → ") 
  };
}

/**
 * Checks if a sequence of segments could be validly generated by our pattern system (legacy)
 */
function isValidGeneration(segments: string[], language: LanguageDefinition): boolean {
  return isValidGenerationWithPath(segments, language).isValid;
}

/**
 * Removes duplicate segmentations based on segment arrays
 */
function removeDuplicateSegmentations(segmentations: NameSegmentation[]): NameSegmentation[] {
  const seen = new Set<string>();
  return segmentations.filter(seg => {
    const key = seg.segments.join('|');
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}

/**
 * Formats a segmentation for display
 */
export function formatSegmentation(segmentation: NameSegmentation): string {
  const segmentLines = segmentation.segments.map((segment, index) => {
    const meaning = segmentation.meanings[index];
    if (segmentation.segments.length === 1) {
      return `${segment}: ${meaning}`;
    } else if (index === 0) {
      return `${segment}-: ${meaning}`;
    } else if (index === segmentation.segments.length - 1) {
      return `-${segment}: ${meaning}`;
    } else {
      return `-${segment}-: ${meaning}`;
    }
  }).join('\n');

  // Add pattern path if available
  if (segmentation.patternPath) {
    return segmentLines + '\n\nPattern path: ' + segmentation.patternPath;
  }
  
  return segmentLines;
}

/**
 * Generates name suggestions based on the input name
 */
function generateNameSuggestions(inputName: string, isAlreadyGeneratable: boolean, language: LanguageDefinition): NameSuggestion[] {
  const suggestions: NameSuggestion[] = [];
  const name = inputName.toLowerCase();
  
  // Get all available starting elements
  const startingElements = language.patterns[language.options.startMarker] || [];
  
  // Strategy 1: Find similar sounding starting elements
  const similarStarts = startingElements.filter(start => {
    if (name.startsWith(start)) return false; // Don't suggest exact matches
    return hasSimilarSound(name.substring(0, Math.min(4, name.length)), start);
  });

  // Strategy 2: Extract recognizable parts and build around them
  const recognizedParts = findRecognizedParts(name, language);
  
  // Strategy 3: Sound-alike replacements
  const soundAlikes = generateSoundAlikeSuggestions(name, language);
  
  // Generate suggestions from similar starts
  for (const start of similarStarts.slice(0, 3)) {
    const compatibleEndings = getCompatibleEndings(start, language);
    for (const ending of compatibleEndings.slice(0, 2)) {
      const suggestedName = capitalizeFirst(start + ending);
      const segments = [start, ending];
      const meanings = segments.map(seg => language.meanings[seg] || 'unknown');
      const similarity = calculateSimilarity(name, start + ending);
      
      suggestions.push({
        name: suggestedName,
        segments: segments,
        meanings: meanings,
        similarity: similarity,
        reason: `Similar sound to "${inputName}" with authentic structure`
      });
    }
  }

  // Generate suggestions from recognized parts
  for (const part of recognizedParts.slice(0, 2)) {
    const alternatives = generateAlternativesWithPart(part, name, language);
    suggestions.push(...alternatives);
  }

  // Add sound-alike suggestions
  suggestions.push(...soundAlikes.slice(0, 3));

  // If the name is already generatable, suggest variations
  if (isAlreadyGeneratable) {
    const variations = generateVariations(name, language);
    suggestions.push(...variations.slice(0, 2));
  }

  // Remove duplicates and sort by similarity
  const uniqueSuggestions = removeDuplicateSuggestions(suggestions);
  return uniqueSuggestions
    .sort((a, b) => b.similarity - a.similarity)
    .slice(0, 6); // Return top 6 suggestions
}

/**
 * Checks if two strings have similar sounds
 */
function hasSimilarSound(str1: string, str2: string): boolean {
  if (str1.length === 0 || str2.length === 0) return false;
  
  // Check for similar starting sounds
  const firstChar1 = str1[0];
  const firstChar2 = str2[0];
  
  // Similar consonant groups
  const similarConsonants = [
    ['b', 'p'], ['d', 't'], ['g', 'k'], ['f', 'v'], 
    ['s', 'th'], ['l', 'r'], ['m', 'n']
  ];
  
  // Check if first characters are in the same similar group
  for (const group of similarConsonants) {
    if (group.includes(firstChar1) && group.includes(firstChar2)) {
      return true;
    }
  }
  
  // Check if they start with the same character
  return firstChar1 === firstChar2;
}

/**
 * Find parts of the name that are recognized elements from the language
 */
function findRecognizedParts(name: string, language: LanguageDefinition): string[] {
  const parts: string[] = [];
  const allElements = Object.keys(language.meanings);
  
  for (const element of allElements) {
    if (name.includes(element) && element.length >= 2) {
      parts.push(element);
    }
  }
  
  return parts.sort((a, b) => b.length - a.length); // Longer parts first
}

/**
 * Get endings that are compatible with a given starting element
 */
function getCompatibleEndings(start: string, language: LanguageDefinition): string[] {
  const possibleContinuations = language.patterns[start] || [];
  const endings: string[] = [];
  
  for (const continuation of possibleContinuations) {
    if (continuation === language.options.endMarker) continue; // Skip direct endings
    
    const continuationPossibilities = language.patterns[continuation] || [];
    if (continuationPossibilities.includes(language.options.endMarker)) {
      endings.push(continuation);
    }
  }
  
  return endings;
}

/**
 * Generate alternatives that include a specific recognized part
 */
function generateAlternativesWithPart(part: string, originalName: string, language: LanguageDefinition): NameSuggestion[] {
  const alternatives: NameSuggestion[] = [];
  const startingElements = language.patterns[language.options.startMarker] || [];
  
  // Try the part as an ending
  for (const start of startingElements.slice(0, 3)) {
    if (start === part) continue;
    
    const startPossibilities = language.patterns[start] || [];
    if (startPossibilities.includes(part)) {
      const suggestedName = capitalizeFirst(start + part);
      const similarity = calculateSimilarity(originalName, start + part);
      
      alternatives.push({
        name: suggestedName,
        segments: [start, part],
        meanings: [language.meanings[start] || 'unknown', language.meanings[part] || 'unknown'],
        similarity: similarity,
        reason: `Incorporates "${part}" from your original name with better structure`
      });
    }
  }
  
  return alternatives;
}

/**
 * Generate sound-alike suggestions
 */
function generateSoundAlikeSuggestions(name: string, language: LanguageDefinition): NameSuggestion[] {
  const suggestions: NameSuggestion[] = [];
  const startingElements = language.patterns[language.options.startMarker] || [];
  
  // Find starts that sound similar to the beginning of the name
  for (const start of startingElements) {
    if (hasSimilarSound(name.substring(0, 3), start)) {
      const compatibleEndings = getCompatibleEndings(start, language);
      for (const ending of compatibleEndings.slice(0, 1)) {
        const suggestedName = capitalizeFirst(start + ending);
        const similarity = calculateSimilarity(name, start + ending);
        
        suggestions.push({
          name: suggestedName,
          segments: [start, ending],
          meanings: [language.meanings[start] || 'unknown', language.meanings[ending] || 'unknown'],
          similarity: similarity,
          reason: `Sound-alike alternative with clearer meaning`
        });
      }
    }
  }
  
  return suggestions;
}

/**
 * Generate variations of an already valid name
 */
function generateVariations(name: string, language: LanguageDefinition): NameSuggestion[] {
  const variations: NameSuggestion[] = [];
  
  // This would implement variations like changing endings or prefixes
  // For now, return empty array
  
  return variations;
}

/**
 * Calculate similarity between two names (0-100)
 */
function calculateSimilarity(name1: string, name2: string): number {
  const len1 = name1.length;
  const len2 = name2.length;
  const maxLen = Math.max(len1, len2);
  
  if (maxLen === 0) return 100;
  
  // Simple similarity based on common characters and length
  let commonChars = 0;
  const minLen = Math.min(len1, len2);
  
  for (let i = 0; i < minLen; i++) {
    if (name1[i] === name2[i]) {
      commonChars++;
    }
  }
  
  // Bonus for similar length
  const lengthSimilarity = 1 - Math.abs(len1 - len2) / maxLen;
  const charSimilarity = commonChars / maxLen;
  
  return Math.round((lengthSimilarity * 0.3 + charSimilarity * 0.7) * 100);
}

/**
 * Remove duplicate suggestions
 */
function removeDuplicateSuggestions(suggestions: NameSuggestion[]): NameSuggestion[] {
  const seen = new Set<string>();
  return suggestions.filter(suggestion => {
    if (seen.has(suggestion.name.toLowerCase())) {
      return false;
    }
    seen.add(suggestion.name.toLowerCase());
    return true;
  });
}

/**
 * Capitalize first letter
 */
function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Quick check if a name is potentially analyzable (contains known elements)
 */
export function isNameAnalyzable(name: string, language: LanguageDefinition): boolean {
  const lowercaseName = name.toLowerCase();
  const allElements = [...Object.keys(language.patterns), ...Object.keys(language.meanings)];
  
  return allElements.some(element => lowercaseName.includes(element));
}

/**
 * Generic name analyzer that automatically selects the appropriate language
 * Currently defaults to Old English, but can be extended to detect language or use preferences
 */
export function analyzeNameGeneric(inputName: string): AnalysisResult {
  // For now, default to Old English
  // In the future, this could:
  // - Auto-detect the language based on patterns
  // - Use user preferences
  // - Accept a language parameter from URL/settings
  return analyzeName(inputName, oldEnglish);
}