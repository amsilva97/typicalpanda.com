import { oldEnglishPatterns } from '../patterns/oldEnglish';
import { oldEnglishMeanings } from '../meanings/oldEnglishMeanings';

export interface NameSegmentation {
  segments: string[];
  meanings: string[];
  isValid: boolean;
}

export interface AnalysisResult {
  name: string;
  isGeneratable: boolean;
  segmentations: NameSegmentation[];
  totalCombinations: number;
}

/**
 * Analyzes a name to find all possible valid segmentations using Old English patterns
 */
export function analyzeOldEnglishName(inputName: string): AnalysisResult {
  const name = inputName.toLowerCase().trim();
  if (!name) {
    return {
      name: inputName,
      isGeneratable: false,
      segmentations: [],
      totalCombinations: 0
    };
  }

  const validSegmentations: NameSegmentation[] = [];

  // Find all possible ways to segment the name
  function findSegmentations(remainingName: string, currentSegments: string[], startIndex: number): void {
    // If we've consumed the entire name, this is a valid segmentation
    if (remainingName.length === 0) {
      // Verify this segmentation could be generated by checking pattern connections
      if (isValidGeneration(currentSegments)) {
        const meanings = currentSegments.map(segment => 
          oldEnglishMeanings[segment] || 'unknown element'
        );
        
        validSegmentations.push({
          segments: [...currentSegments],
          meanings: meanings,
          isValid: true
        });
      }
      return;
    }

    // Try all possible segments starting from current position
    for (let i = 1; i <= remainingName.length; i++) {
      const segment = remainingName.substring(0, i);
      
      // Check if this segment exists in our patterns or meanings dictionary
      if (oldEnglishPatterns.hasOwnProperty(segment) || oldEnglishMeanings.hasOwnProperty(segment)) {
        // Recursively try to segment the rest
        findSegmentations(
          remainingName.substring(i),
          [...currentSegments, segment],
          startIndex + i
        );
      }
    }
  }

  // Start the segmentation process
  findSegmentations(name, [], 0);

  // Remove duplicate segmentations
  const uniqueSegmentations = removeDuplicateSegmentations(validSegmentations);

  return {
    name: inputName,
    isGeneratable: uniqueSegmentations.length > 0,
    segmentations: uniqueSegmentations,
    totalCombinations: uniqueSegmentations.length
  };
}

/**
 * Checks if a sequence of segments could be validly generated by our pattern system
 */
function isValidGeneration(segments: string[]): boolean {
  if (segments.length === 0) return false;

  // Check if the first segment can start a name (appears in ^ pattern)
  const startingPatterns = oldEnglishPatterns["^"] || [];
  if (!startingPatterns.includes(segments[0])) {
    return false;
  }

  // Check if each segment can lead to the next
  for (let i = 0; i < segments.length - 1; i++) {
    const currentSegment = segments[i];
    const nextSegment = segments[i + 1];
    
    const possibleContinuations = oldEnglishPatterns[currentSegment] || [];
    if (!possibleContinuations.includes(nextSegment)) {
      return false;
    }
  }

  // Check if the last segment can end (has $ in its possibilities)
  const lastSegment = segments[segments.length - 1];
  const lastPossibilities = oldEnglishPatterns[lastSegment] || [];
  if (!lastPossibilities.includes("$")) {
    return false;
  }

  return true;
}

/**
 * Removes duplicate segmentations based on segment arrays
 */
function removeDuplicateSegmentations(segmentations: NameSegmentation[]): NameSegmentation[] {
  const seen = new Set<string>();
  return segmentations.filter(seg => {
    const key = seg.segments.join('|');
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}

/**
 * Formats a segmentation for display
 */
export function formatSegmentation(segmentation: NameSegmentation): string {
  return segmentation.segments.map((segment, index) => {
    const meaning = segmentation.meanings[index];
    if (segmentation.segments.length === 1) {
      return `${segment}: ${meaning}`;
    } else if (index === 0) {
      return `${segment}-: ${meaning}`;
    } else if (index === segmentation.segments.length - 1) {
      return `-${segment}: ${meaning}`;
    } else {
      return `-${segment}-: ${meaning}`;
    }
  }).join('\n');
}

/**
 * Quick check if a name is potentially analyzable (contains known elements)
 */
export function isNameAnalyzable(name: string): boolean {
  const lowercaseName = name.toLowerCase();
  const allElements = [...Object.keys(oldEnglishPatterns), ...Object.keys(oldEnglishMeanings)];
  
  return allElements.some(element => lowercaseName.includes(element));
}